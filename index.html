<!DOCTYPE html>
<html>
<head>
	<title>Thorana</title>
	<meta charset="utf-8">
</head>
<body>
	<canvas style="background: rgba(0,0,0,0.9);width: 100%;height: 100%" id="myCanvas">
		Your browser not supported. please try with a different device.
	</canvas>
	<!-- <audio id="theAudio" src="images/ASEMATUWANA.MP3" controls></audio> -->

	<script>

		// var audioElement = document.getElementById("theAudio");
		// audioElement.play();
		// audioElement.setAttribute('style','display:none');

		var myCanvas;
		var canvasWidth,canvasHeight;
		var ww,hw;
		var w,h;
		var context;
		var r,R,z; //radius of circles and z = sin(pi/8)
		var marginTop,marginBotom;
		var cx = new Array();
		var cy = new Array();
		var pointSqx,pointSqy; // starting point of squre down
		var dimPointSqx,dimPointSqy; // end point of squre down
		var fractionOfDispSmall,fractionOfDispLarge //bulb display area as fraction of radius
		var angleBC; 	//angle between box and botom circle center (c0)
		var leftImgBoxStartX,leftImgBoxStartY,rightImgBoxStartX,rightImgBoxStartY; //starting coodinates of first image boxes
		var leftImageBoxW,leftImageBoxH,rightImgBoxW,rightImgBoxH; // dimensions of image boxes	
		var imageBoxPadding;

		window.onload = function(){
			ww = window.innerWidth;
			hw = window.innerHeight;

			myCanvas = document.getElementById('myCanvas');
			myCanvas.width = ww;
			myCanvas.height = ww/2; 

			w = myCanvas.width;
			h = myCanvas.height;

			//calculate r and R (radii) - *get canvas dimentions [leave margings from top and bottom and use rest for draw circles]
			marginTop = 0.04;  // 4% of w
			marginBotom = 0.1; // 10% of w
			z = Math.sin(Math.PI/8);
			r = ((1 - (marginTop + marginBotom)) / 4) * (z / (z + 1)) * w;
			R = ((1 - z) / z) * r;

			// calculate center possitions of each circles
			cx[0] = w/2;	// centers of main circle
			cy[0] = (h/2)*(1 + marginTop - marginBotom);

			for (var i = 0; i <= 7; i++) {
				// creating x coordinates of centers
				cx[i+1] = cx[0] + (R + r) * Math.sin(i*(Math.PI/4));
			}

			for (var i = 0; i <= 7; i++) {
				// creating y coordinates of centers
				cy[i+1] = cy[0] + (R + r) * Math.cos(i*(Math.PI/4));
			}

			// calculate dimentions of down square
			pointSqx = cx[0] - (R + 3*r);		// starting point
			pointSqy = (cy[0] + r) + ((R + r)/(Math.sqrt(2)));
			dimPointSqx = 6*r + 2*R;			// dimensions
			dimPointSqy = 0.98*h - pointSqy;

			// get context of the canvas
			context = myCanvas.getContext("2d");
			
			// draw square
			context.beginPath();
			context.strokeStyle = "rgba(255,255,255,1)";
			context.fillStyle = "rgba(0,0,0,0.4)";
			context.strokeRect(pointSqx,pointSqy,dimPointSqx,dimPointSqy);
			context.fillRect(pointSqx,pointSqy,dimPointSqx,dimPointSqy);
			context.fill();
			context.closePath();

			// create image boxess
			imageBoxPadding = 0.01*h;
			// create left image box
			var d = (r - cy[1] + cy[8])/r;
			angleBC = Math.acos(d);
			leftImgBoxStartX = pointSqx + imageBoxPadding;
			leftImgBoxStartY = pointSqy + imageBoxPadding;
			leftImageBoxH = dimPointSqy - 2*imageBoxPadding;
			leftImageBoxW = R +3*r - r*Math.sin(angleBC) - 2*imageBoxPadding;

			var imageBoxLeft = new Image();
			imageBoxLeft.src = "images/data5.jpg";
			imageBoxLeft.addEventListener('load',function(){
				context.drawImage(imageBoxLeft,leftImgBoxStartX,leftImgBoxStartY,leftImageBoxW,leftImageBoxH);		
			});

			// create right image box
			rightImgBoxStartX = cx[0] + r*Math.sin(angleBC) + imageBoxPadding;
			rightImgBoxStartY = cy[1] + r*Math.cos(angleBC) + imageBoxPadding;
			rightImgBoxH = leftImageBoxH ;//- 2*imageBoxPadding already added;
			rightImgBoxW = leftImageBoxW ;//- 2*imageBoxPadding already added;

			var imageBoxRight = new Image();
			imageBoxRight.src = "images/data5.jpg";
			imageBoxRight.addEventListener('load',function(){
				context.drawImage(imageBoxRight,rightImgBoxStartX,rightImgBoxStartY,rightImgBoxW,rightImgBoxH);		
			});


			for(var i = 0; i <= cx.length ; i++){
				//draw outer circle of each circles
				context.beginPath();
				context.strokeStyle = "rgba(255,255,255,1)";
				context.fillStyle = "rgba(0,0,0,1)";
				if (i == 0) {
					context.arc(cx[i],cy[i],R,Math.PI*2,false);
				}else{
					context.arc(cx[i],cy[i],r,Math.PI*2,false);
				}
				context.stroke();
				context.fill();
				context.closePath();
			}

			fractionOfDispSmall = 0.6 ;
			fractionOfDispLarge = 0.2 ;
			for(var i = 0; i <= cx.length ; i++){
				//draw inner circle of each circles
				context.beginPath();
				context.strokeStyle = "rgba(255,255,255,1)";
				context.fillStyle = "rgba(255,255,255,0.7)";
				if (i == 0) {
					context.arc(cx[i],cy[i], R * fractionOfDispLarge , Math.PI*2,false);
				}else{
					context.arc(cx[i],cy[i], r* fractionOfDispSmall , Math.PI*2,false);
				}
				context.stroke();
				context.fill();
				context.closePath();
			}

			// // small circles inner Bulb set
			// var dotSize = 0.0015*w;
			// var dotsForSmallCircle = {
			// 	numberOfDots : [50,60,70],
			// 	radii : [0.7,0.8,0.9]
			// };

			// for (var k = 0; k < dotsForSmallCircle.radii.length; k++) {
			// 	context.strokeStyle = "rgba(255,255,255,0.2)";
			// 	context.fillStyle = "rgba(255,255,255,0.2)";
			// 	for (var j = 1; j < cx.length; j++) {
			// 		for(var i = 0; i<dotsForSmallCircle.numberOfDots[k] ;i++){
			// 			context.beginPath();
			// 			context.arc(cx[j] + r * dotsForSmallCircle.radii[k] * Math.cos(2*Math.PI/dotsForSmallCircle.numberOfDots[k]*i) ,
			// 				cy[j] + r * dotsForSmallCircle.radii[k] * Math.sin(2*Math.PI/dotsForSmallCircle.numberOfDots[k]*i),
			// 				dotSize,Math.PI*2,
			// 				false);
			// 			context.stroke();
			// 			context.fill();
			// 			context.closePath();	
			// 		}
			// 	}
			// }
			
			var intensity = 0.9 ;
			function draw(){
				// small circles inner Bulb set
				var dotSize = 0.003*w;
				var dotsForSmallCircle = {
					numberOfDots : [20,25,30],
					radii : [0.7,0.8,0.9]
				};

				// intensity = intensity + 0.01;
				// if (intensity >0.9 ) {
				// 	intensity = 0.1;
				// }
			
				for (var k = 0; k < dotsForSmallCircle.radii.length; k++) {
					// context.strokeStyle = "rgba(255,255,255,"+intensity+")";
					context.fillStyle = "rgba("+Math.random()*255+","+Math.random()*255+","+Math.random()*255+","+intensity+")";
					for (var j = 1; j < cx.length; j++) {
						for(var i = 0; i<dotsForSmallCircle.numberOfDots[k] ;i++){
							context.beginPath();
							context.clearRect(cx[j] + r * dotsForSmallCircle.radii[k] * Math.cos(2*Math.PI/dotsForSmallCircle.numberOfDots[k]*i) - dotSize,
								cy[j] + r * dotsForSmallCircle.radii[k] * Math.sin(2*Math.PI/dotsForSmallCircle.numberOfDots[k]*i) - dotSize,
								2*dotSize,
								2*dotSize);

							context.arc(cx[j] + r * dotsForSmallCircle.radii[k] * Math.cos(2*Math.PI/dotsForSmallCircle.numberOfDots[k]*i) ,
								cy[j] + r * dotsForSmallCircle.radii[k] * Math.sin(2*Math.PI/dotsForSmallCircle.numberOfDots[k]*i),
								dotSize,
								Math.PI*2,
								false);
							// context.stroke();
							context.fill();
							context.closePath();	
						}
					}
				}
				requestAnimationFrame(draw);
			}

			var image = new Image();
			image.src = "images/e0499.png";
			image.addEventListener('load',function(){
				for(var i = 1; i < cx.length ; i++){
					context.drawImage(image,(cx[i] - r*fractionOfDispSmall),(cy[i] - r*fractionOfDispSmall),fractionOfDispSmall*2*r,fractionOfDispSmall*2*r);
				}
			});

			var imageCenter = new Image();
			var dim = 2*R*Math.sin(Math.atan(0.5));
			imageCenter.src = "images/e1472.png";
			imageCenter.addEventListener('load',function(){
				context.drawImage(imageCenter,(cx[0] - R*Math.sin(Math.PI/6) + 0.005*w),cy[0],dim,dim);
				
			});

			draw();
		}
	</script>
</body>
</html>